MODULE COST_MODULE
USE CONSTANTS
USE MATH_MODULE
USE ORBITAL_FUNCTIONS
IMPLICIT NONE

CONTAINS

!********************************************************************!
!********************************************************************!
!********************************************************************!
!********************************************************************!
! THIS COST FUNCTION COMPUTES A MODIFIED THE COST VALUE OF A MODIFIED
! SIMS-FLANAGAN LOW-THRUST TRANSCRIPTION MODEL.  ESSENTIALLY THE 6 
! POSITION AND VELOCITY MATCHING CONSTRAINTS FOR EACH LEG ARE 
! CONVERTED TO VELOCITY INEQUALITY CONSTRAINTS BY REPLACING THE 
! MIDDLE ARCE WITH A SOLUTION TO LAMBERTS PROBLEM.  THIS CAN RESULT 
! IN DELTA-V'S THAT ARE LARGER THAN THE THRUSTERS COULD HANDLE, BUT
! THE SOLVER CAN TYPICALLY DEAL WITH THIS BY USING THE CONMIN NLP
! SOLVER WITH INEQUALITY CONSTRAINTS.

SUBROUTINE COST(N_DOUBLE, N_INT, N1, N2, CHROM_DOUBLE, CHROM_INT, &
    FITNESS, ASTEROID, G_CON, NCON)

IMPLICIT NONE


! VARIABLES THAT ARE ACTUALLY USED FOR THE COST FUNCTION
INTEGER, INTENT(IN) :: N_INT, N_DOUBLE, N1, N2, CHROM_INT(N_INT), &
    NCON
DOUBLE PRECISION, INTENT(IN) :: ASTEROID(N1,N2), &
    CHROM_DOUBLE(N_DOUBLE)
DOUBLE PRECISION, INTENT(INOUT) :: FITNESS, G_CON(NCON)

!OTHER VARIABLES
DOUBLE PRECISION :: M0, J1, J2, J3, J4, T1, T2, T3, T4, C3_DEP, &
    ALPHA_DEP, BETA_DEP, DV_MAX, DT, C3_ARR, ALPHA_ARR, BETA_ARR, &
    ISP, g0, T_MAX, m_DOT, K, MASS, M_AST, M_AST_ARR, R0(3),V0(3), &
    V_SC(3), R(3), V(3), SV(6), OE(6) , DV_VEC(3), THETA, PHI, &
    MASS_START_DEP, R_FW(3), V_FW(3), R_BW(3), V_BW(3), &
    R_PATCH_DEP(3),V_PATCH_DEP(3), R_PATCH_ARR(3), V_PATCH_ARR(3), &
    WEIGHT(5), R_LAMBERT1(3), R_LAMBERT2(3), V_LAMBERT11(3),&
    V_LAMBERT12(3), V_LAMBERT21(3), V_LAMBERT22(3), V_LAMBERT(6), &
    VEC_DUM(3), DV_MAX_FW, DV_MAX_BW

DOUBLE PRECISION, ALLOCATABLE :: EPS_DEP(:), THETA_DEP(:), PHI_DEP(:),&
    DV_DEP(:), EPS_ARR(:), THETA_ARR(:), PHI_ARR(:), DV_ARR(:), &
    DUM_ARRAY(:)

INTEGER :: P1,P2, I, N, INDEX, OT


OT=1   !ORBIT TYPE FOR LAMBERT SOLVER 1=PROGRADE

P1=CHROM_INT(1) ! INITIAL DEPARTURE PLANET (SHOULD ALSO BE 3 FOR EARTH)
P2=CHROM_INT(2) ! FINAL ARRIVAL PLANET (SHOULD ALWAYS BE 10 SO THE ASTEROID EPHEMERIS DATA IS USED)

! INITIAL SPACECRAFT MASS CORRESPONDING TO THE KECK STUDY NUMBERS
M0=15000.D0

! ASSUMED ASTEROID MASS.  FOR NOW THIS IS A SET MASS, BUT IT WOULD PROBABLY BY POSSIBLE TO LET THIS VARY.  
! IN THAT CASE THE SOLVER SHOULD BE ABLE TO DETERMINE THE MAXIMUM POSSIBLE MASS THAT COULD BE RETURN. 
! HOWEVER, I SUSPECT DOING THIS WOULD LIKELY RESULT IN ALL OF THE FUEL BEING USED FOR THE TRANSFER.
M_AST=500000.D0


!MAXIMUM POSSIBLE THRUST FROM 2XBUSEK-BHT 20K THRUSTERS
T_MAX=0.00216D0
!THRUSTER MASS FLOW RATE
M_DOT=2.D0*4.D-5
! IF YOU CHANGE EITHER THE THRUST OR MASS FLOW RATE BE SURE YOU ARE USING THE RIGHT UNITS TO MATCH WITH
! THE SUNS MU GRAVITATIONAL PARAMETER DEFINED IN THE CONSTANTS MODULE.


! ENGINE EFFICIENCY FACTORY.  FOR NOW THIS IS SET TO 1.
K=1.D0

ISP=2750.D0 ! THRUST SPECIFIC IMPULSE
g0=0.0098065D0 ! SEA LEVEL GRAVITATIONAL CONSTANT


! DEPARTURE C3.  FOR NOW IT'S ALWAYS ASSUMED TO BE 2.0, BUT IT MIGHT BE A GOOD IDEA TO MAKE IT A VARIABLE.
C3_DEP=2.D0

J1=CHROM_DOUBLE(1)        ! DEPARTURE DATE
ALPHA_DEP=CHROM_DOUBLE(2) ! DEPARTURE ASCENCION ANGLE (RAD)
BETA_DEP=CHROM_DOUBLE(3)  ! DEPARTURE DECLINATION ANGLE (RAD)
T1=CHROM_DOUBLE(4)        ! TOF TO ASTEROID
T2=CHROM_DOUBLE(5)        ! ASTEROID STAY TIME
T3=CHROM_DOUBLE(6)        ! TOF BACK TO EARTH WITH ASTEROID IN TOW
C3_ARR=CHROM_DOUBLE(7)    ! ARRIVAL C3.  THIS IS ALLOWED TO VARY BETWEEN 0 AND 2.0 (AS DEFINED IN THE DRIVER FILE)
ALPHA_ARR=CHROM_DOUBLE(8) ! ARRIVAL ASCENCION ANGLE (RAD)
BETA_ARR=CHROM_DOUBLE(9)  ! ARRIVAL DECLINATION ANGLE (RAD)

J2=J1+T1 ! ASTEROID ARRIVAL DATE
J3=J2+T2 ! ASTEROID DEPARTURE DATE
J4=J3+T3 ! EARTH PROXIMITY ARRIVAL DATE


! THE VARIABLES TO DEFINE EACH SEPARATE BURN FOR THE MODIFIED SIMS FLANAGAN 
! TRANSCRIPTION.  NOTE THIS SHOULD MATCH HOW THEY'RE DEFINED IN THE DRIVER FILE.
N=(N_DOUBLE-9)/6 ! N IS THE NUMBER OF INDIVIDUAL IMPULSE FOR EACH MISSION LEG

ALLOCATE(EPS_DEP(N+2), THETA_DEP(N+2), PHI_DEP(N+2), DV_DEP(N+2))
ALLOCATE(EPS_ARR(N+2), THETA_ARR(N+2), PHI_ARR(N+2), DV_ARR(N+2))
ALLOCATE(DUM_ARRAY(N))

! THIS STEP SIMPLY INITIALIZE EACH ARRAY
EPS_DEP=0.D0
EPS_ARR=0.D0
THETA_DEP=0.D0
THETA_ARR=0.D0
PHI_DEP=0.D0
PHI_ARR=0.D0


INDEX=10 
! INDEX IS THE STARTING POINT FOR EACH ARRAY OF VARIABLES.  THE FIRST 9 
! VARIABLES ARE SIMPLY THE OTHER PROBLEM VARIABLES PREVIOUSLY DEFINED.

! ASSIGN DEPARTURE VARIABLE ARRAYS FROM THE INPUT CHROMOSOME
DUM_ARRAY=CHROM_DOUBLE(INDEX:INDEX+N)
EPS_DEP(1:N/2)=DUM_ARRAY(1:N/2)
EPS_DEP(N/2+3:N+2)=DUM_ARRAY(N/2+1:N)

INDEX=INDEX+N
DUM_ARRAY=CHROM_DOUBLE(INDEX:INDEX+N-1)
THETA_DEP(1:N/2)=DUM_ARRAY(1:N/2)
THETA_DEP(N/2+3:N+2)=DUM_ARRAY(N/2+1:N)


INDEX=INDEX+N
DUM_ARRAY=CHROM_DOUBLE(INDEX:INDEX+N-1)
PHI_DEP(1:N/2)=DUM_ARRAY(1:N/2)
PHI_DEP(N/2+3:N+2)=DUM_ARRAY(N/2+1:N)

! ASSIGN THE EARTH RETURN VARIABLE ARRAYS FROM THE INPUT CHROMOSOME
INDEX=INDEX+N
DUM_ARRAY=CHROM_DOUBLE(INDEX:INDEX+N-1)
EPS_ARR(1:N/2)=DUM_ARRAY(1:N/2)
EPS_ARR(N/2+3:N+2)=DUM_ARRAY(N/2+1:N)


INDEX=INDEX+N
DUM_ARRAY=CHROM_DOUBLE(INDEX:INDEX+N-1)
THETA_ARR(1:N/2)=DUM_ARRAY(1:N/2)
THETA_ARR(N/2+3:N+2)=DUM_ARRAY(N/2+1:N)


INDEX=INDEX+N
DUM_ARRAY=CHROM_DOUBLE(INDEX:INDEX+N-1)
PHI_ARR(1:N/2)=DUM_ARRAY(1:N/2)
PHI_ARR(N/2+3:N+2)=DUM_ARRAY(N/2+1:N)


N=N+2

!********************************************************************!
!******COMPUTE TRAJECTORY FOR INITIAL EARTH TO ASTEROID LEG**********!
!********************************************************************!

! DETERMINE INITIAL TIME STEP FOR EACH SHORT LEFT AND MAXIMUM POSSIBLE DELTA-V'S 
DT=86400.D0*T1/DBLE(N)
DV_MAX=T_MAX/M_DOT*LOG(M0/(M0-M_DOT*K*DT))
DV_MAX_FW=DV_MAX
!PROPOGATE THE ORBIT FORWARD FROM THE STARTING POINT HERE 
CALL PLAN_ELEM(J1, P1,ASTEROID,N1,N2,OE)
SV=OE2SV(OE(1),OE(2),OE(3),OE(4),OE(5),OE(6))
R=SV(1:3)
V0=SV(4:6)
R0=R
V_SC(1)=SQRT(C3_DEP)*COS(ALPHA_DEP)*COS(BETA_DEP)
V_SC(2)=SQRT(C3_DEP)*SIN(ALPHA_DEP)*COS(BETA_DEP)
V_SC(3)=SQRT(C3_DEP)*SIN(BETA_DEP)
V=V0+V_SC
SV=ORBIT_PROPOGATION(R,V,DT*0.5D0)

MASS=M0
DO I=1,N/2,1

  IF (I.NE.(N/2)) THEN

    R=SV(1:3)
    V=SV(4:6)
    THETA=THETA_DEP(I)
    PHI=PHI_DEP(I)
    DV_VEC(1)=EPS_DEP(I)*DV_MAX*(COS(THETA)*SIN(PHI))
    DV_VEC(2)=EPS_DEP(I)*DV_MAX*(SIN(THETA)*SIN(PHI))
    DV_VEC(3)=EPS_DEP(I)*DV_MAX*(COS(PHI))
    DV_DEP(I)=EPS_DEP(I)*DV_MAX
    R=SV(1:3)
    V=SV(4:6)+DV_VEC
    SV=ORBIT_PROPOGATION(R,V,DT)
    MASS=MASS*EXP(-DV_DEP(I)/(g0*ISP))

  ELSE
    ! INSTEAD OF PROPOGATING TO A MATCHPOINT  
    R_LAMBERT1=SV(1:3)
    V_LAMBERT11=SV(4:6)
  END IF


  
END DO

!PROPOGATE THE ORBIT BACKWARD HERE

DV_MAX=T_MAX/M_DOT*LOG(MASS/(MASS-M_DOT*K*DT))
DV_MAX_BW=DV_MAX
!WRITE(*,*) "CALL PLANETARY ELEMENTS"
!WRITE(*,*) ASTEROID(1,1)
CALL PLAN_ELEM(J2, P2,ASTEROID,N1,N2,OE)
!WRITE(*,*) "FOUND PLANETARY ELEMENTS"
SV=OE2SV(OE(1),OE(2),OE(3),OE(4),OE(5),OE(6))
R=SV(1:3)
V=SV(4:6)
SV=ORBIT_PROPOGATION(R, V, -0.5*DT)

DO I=N,N/2+1,-1

  IF(I.NE.(N/2+1)) THEN
    R=SV(1:3)
    V=SV(4:6)
    THETA=THETA_DEP(I)
    PHI=PHI_DEP(I)
    DV_VEC(1)=EPS_DEP(I)*DV_MAX*(COS(THETA)*SIN(PHI))
    DV_VEC(2)=EPS_DEP(I)*DV_MAX*(SIN(THETA)*SIN(PHI))
    DV_VEC(3)=EPS_DEP(I)*DV_MAX*(COS(PHI))
    DV_DEP(I)=EPS_DEP(I)*DV_MAX
    R=SV(1:3)
    V=SV(4:6)+DV_VEC
    SV=ORBIT_PROPOGATION(R,V,-DT)
  
  ELSE
    R_LAMBERT2=SV(1:3)
    V_LAMBERT22=SV(4:6)
  END IF
END DO
! NOW THE LAMBERT PATCH MUST BE APPLIED

CALL LAMBERT_SUN(R_LAMBERT1,R_LAMBERT2,DT,OT, V_LAMBERT)
V_LAMBERT12=V_LAMBERT(1:3)
V_LAMBERT21=V_LAMBERT(4:6)
VEC_DUM=V_LAMBERT11-V_LAMBERT12
DV_DEP(N/2)=NORM(VEC_DUM)
VEC_DUM=V_LAMBERT21-V_LAMBERT22
DV_DEP(N/2+1)=NORM(VEC_DUM)

! THIS CHECK WAS ADDED IN SO THE NLP SOLVER DIDN'T WASTE TIME ON WHAT ARE LIKELY
! BAD TRAJECTORY CANDIDATES.
IF (DV_DEP(N/2).GT.25.D0) THEN
    DV_DEP(N/2)=25.D0
END IF

IF (DV_DEP(N/2+1).GT.25.D0) THEN
    DV_DEP(N/2+1)=25.D0
END IF

!WRITE(*,*) DV_DEP(N/2)
!WRITE(*,*) DV_DEP(N/2+1)

! NOW WE SET UP THE TWO CONSTRAINTS FOR THIS LEG.
!  WHICH ENSURES THAT THE TWO dV'S AREN'T LARGER 
!  THAN THE MAX.  IN THIS CASE THE CONSTRAINTS ARE
!  NEGATIVE IF THE CALCULATED dV IS LESS THAN THE 
!  MAXIMUM POSSIBLE dV, WHICH IS HOW MOST NLP SOVLERS
!  ARE SET UP.
G_CON(1)=100.D0*(DV_DEP(N/2)-DV_MAX_FW)
G_CON(2)=100.D0*(DV_DEP(N/2+1)-DV_MAX_BW)

!R_PATCH_DEP=R_FW-R_BW
!V_PATCH_DEP=V_FW-V_BW
! FIND MASS AFTER THE FORWARD PROPOGATION
MASS=M0
DO I=1,N,1
    MASS=MASS*EXP(-DV_DEP(I)/(g0*ISP))
END DO

!********************************************************************!
!******COMPUTE TRAJECTORY FOR FINAL ASTEROID TO EARTH LEG************!
!********************************************************************!
! EVERYTHING IS CALCULATED THE SAME AS WITH THE PRECIOUS LEG, BUT 
! WITH THE ASTEROID MASSED ADDED ON.
MASS=MASS+M_AST
DT=86400.D0*T3/DBLE(N)
DV_MAX=T_MAX/M_DOT*LOG(MASS/(MASS-M_DOT*K*DT))
DV_MAX_FW=DV_MAX
!PROPOGATE THE ORBIT FORWARD FROM THE STARTING POINT HERE 
CALL PLAN_ELEM(J3, P2, ASTEROID,N1,N2,OE)
SV=OE2SV(OE(1),OE(2),OE(3),OE(4),OE(5),OE(6))
R=SV(1:3)
V=SV(4:6)
SV=ORBIT_PROPOGATION(R, V, 0.5*DT)


DO I=1,N/2,1
  IF (I.NE.(N/2)) THEN
    R=SV(1:3)
    V=SV(4:6)
    THETA=THETA_ARR(I)
    PHI=PHI_ARR(I)
    DV_VEC(1)=EPS_ARR(I)*DV_MAX*(COS(THETA)*SIN(PHI))
    DV_VEC(2)=EPS_ARR(I)*DV_MAX*(SIN(THETA)*SIN(PHI))
    DV_VEC(3)=EPS_ARR(I)*DV_MAX*(COS(PHI))
    DV_ARR(I)=EPS_ARR(I)*DV_MAX
    R=SV(1:3)
    V=SV(4:6)+DV_VEC
    SV=ORBIT_PROPOGATION(R,V,DT)
    MASS=MASS*EXP(-DV_ARR(I)/(g0*ISP))
  ELSE
    R_LAMBERT1=SV(1:3)
    V_LAMBERT11=SV(4:6)
  END IF
END DO

!WRITE(*,*) "PROPOGATE BACKWARD 2"
!PROPOGATE THE ORBIT BACKWARD HERE

DV_MAX=T_MAX/M_DOT*LOG(MASS/(MASS-M_DOT*K*DT))
DV_MAX_BW=DV_MAX
CALL PLAN_ELEM(J4, P1, ASTEROID,N1,N2,OE)

SV=OE2SV(OE(1),OE(2),OE(3),OE(4),OE(5),OE(6))
R=SV(1:3)
V0=SV(4:6)
R0=R
V_SC(1)=SQRT(C3_ARR)*COS(ALPHA_ARR)*COS(BETA_ARR)
V_SC(2)=SQRT(C3_ARR)*SIN(ALPHA_ARR)*COS(BETA_ARR)
V_SC(3)=SQRT(C3_ARR)*SIN(BETA_ARR)
V=V0+V_SC
SV=ORBIT_PROPOGATION(R,V,-DT*0.5D0)

DO I=N,N/2+1,-1
  IF(I.NE.(N/2+1)) THEN
    R=SV(1:3)
    V=SV(4:6)
    THETA=THETA_ARR(I)
    PHI=PHI_ARR(I)
    DV_VEC(1)=EPS_ARR(I)*DV_MAX*(COS(THETA)*SIN(PHI))
    DV_VEC(2)=EPS_ARR(I)*DV_MAX*(SIN(THETA)*SIN(PHI))
    DV_VEC(3)=EPS_ARR(I)*DV_MAX*(COS(PHI))
    DV_ARR(I)=EPS_ARR(I)*DV_MAX
    R=SV(1:3)
    V=SV(4:6)+DV_VEC
    SV=ORBIT_PROPOGATION(R,V,-DT)
  
  ELSE
    R_LAMBERT2=SV(1:3)
    V_LAMBERT22=SV(4:6)
  END IF
END DO


CALL LAMBERT_SUN(R_LAMBERT1,R_LAMBERT2,DT,OT, V_LAMBERT)
!IF (V_LAMBERT(1).GT.9.9D11) THEN
!    WRITE(*,*) "LAMBERT DIDN'T CONVERGE"
!ELSE
!    WRITE(*,*) "LAMBERT DID CONVERGE"
!END IF

V_LAMBERT12=V_LAMBERT(1:3)
V_LAMBERT21=V_LAMBERT(4:6)
VEC_DUM=V_LAMBERT11-V_LAMBERT12
DV_ARR(N/2)=NORM(VEC_DUM)
VEC_DUM=V_LAMBERT21-V_LAMBERT22
DV_ARR(N/2+1)=NORM(VEC_DUM)

IF (DV_ARR(N/2).GT.25.D0) THEN
    DV_ARR(N/2)=25.D0
END IF

IF (DV_ARR(N/2+1).GT.25.D0) THEN
    DV_ARR(N/2+1)=25.D0
END IF

! NOW WE SET UP THE TWO CONSTRAINTS FOR THIS LEG.
!  WHICH ENSURES THAT THE TWO dV'S AREN'T LARGER 
!  THAN THE MAX.  IN THIS CASE THE CONSTRAINTS ARE
!  NEGATIVE IF THE CALCULATED dV IS LESS THAN THE 
!  MAXIMUM POSSIBLE dV, WHICH IS HOW MOST NLP SOVLERS
!  ARE SET UP.

G_CON(3)=100.D0*(DV_ARR(N/2)-DV_MAX_FW)
G_CON(4)=100.D0*(DV_ARR(N/2+1)-DV_MAX_BW)


! GO BACK THROUGH AND CALCULATE THE FINAL ARRIVAL MASS NOW THAT THE LAMBERT SECTIONS HAVE BEEN DETERMINED.
MASS=M0
DO I=1,N,1
    MASS=MASS*EXP(-DV_DEP(I)/(g0*ISP))
    !WRITE(*,*) I, MASS, DV_DEP(I)
END DO

M_AST_ARR=MASS
MASS=MASS+M_AST



DO I=1,N,1
    MASS=MASS*EXP(-DV_ARR(I)/(g0*ISP))
    !WRITE(*,*) I, MASS, DV_DEP(I)
END DO

! BECAUSE THE GNLP OPTIMZER DOES MINIMIZATION THE ACTUAL FITNESS VALUE
! IS ACTUALLY CALCULATED AT THE TOTAL CHANGE IN MASS REQUIRED, WHICH 
! IS THEN THE REQUIRED PROPELLANT.

FITNESS=M_AST+M0-MASS

!********************************************************************!
!WRITE(*,*) "MASS AT EARTH ARRIVAL", MASS
!WRITE(*,*) "DV_TOT_DEP           ", SUM(DV_DEP)
!WRITE(*,*) "DV_TOT_ARR           ", SUM(DV_ARR)
!WRITE(*,*) "ARRIVAL C3           ", C3_ARR
!WRITE(*,*) "R_REL_MAG_DEP        ", SQRT(R_PATCH_DEP(1)**2+ &
!    R_PATCH_DEP(2)**2+R_PATCH_DEP(3)**2)
!WRITE(*,*) "V_REL_MAG_DEP        ", SQRT(V_PATCH_DEP(1)**2+ &
!    V_PATCH_DEP(2)**2+V_PATCH_DEP(3)**2)
!WRITE(*,*) "R_REL_MAG_ARR        ", SQRT(R_PATCH_ARR(1)**2+ &
!    R_PATCH_ARR(2)**2+R_PATCH_ARR(3)**2)
!WRITE(*,*) "V_REL_MAG_ARR        ", SQRT(V_PATCH_ARR(1)**2+ &
!    V_PATCH_ARR(2)**2+V_PATCH_ARR(3)**2)


IF (ISNAN(FITNESS))THEN
  FITNESS=1.D30
END IF
IF( FITNESS.GT.100000.D0) THEN
    FITNESS=1.D30
END IF
!END IF
END SUBROUTINE COST



END MODULE COST_MODULE